// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TournamentPrizeDistribution {
    address public owner;
    uint public totalPrize;
    uint public totalDistributed;
    mapping(address => uint) public winnerPrizes;
    address[] public winnerList;
    bool public prizesDistributed;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    event PrizeDistributed(address indexed winner, uint amount);
    event PrizePoolUpdated(uint newTotalPrize);
    event RemainingFundsWithdrawn(uint amount);
    event DistributionReset();

    constructor() payable {
        owner = msg.sender;
        totalPrize = msg.value;
        prizesDistributed = false;
    }

    function distributePrizes(address[] calldata winners, uint[] calldata prizes) external onlyOwner {
        require(!prizesDistributed, "Prizes already distributed");
        require(winners.length == prizes.length, "Mismatch in winners and prizes");

        uint _totalDistributed = 0;

        for (uint i = 0; i < winners.length; i++) {
            winnerPrizes[winners[i]] = prizes[i];
            winnerList.push(winners[i]);
            _totalDistributed += prizes[i];
        }

        require(_totalDistributed <= totalPrize, "Exceeds total prize pool");

        for (uint i = 0; i < winners.length; i++) {
            payable(winners[i]).transfer(prizes[i]);
            emit PrizeDistributed(winners[i], prizes[i]);
        }

        totalDistributed = _totalDistributed;
        prizesDistributed = true;
    }

    function getPrizeAmount(address winner) external view returns (uint) {
        return winnerPrizes[winner];
    }

    function getAllWinners() external view returns (address[] memory) {
        return winnerList;
    }

    function updatePrizeAmount() external payable onlyOwner {
        require(!prizesDistributed, "Cannot add funds after distribution");
        totalPrize += msg.value;
        emit PrizePoolUpdated(totalPrize);
    }

    function withdrawUnclaimedFunds() external onlyOwner {
        require(prizesDistributed, "Distribution not completed");
        uint remaining = address(this).balance;
        payable(owner).transfer(remaining);
        emit RemainingFundsWithdrawn(remaining);
    }

    function resetDistribution() external onlyOwner {
        require(prizesDistributed, "Prizes not yet distributed");

        // Clear winnerPrizes and winnerList
        for (uint i = 0; i < winnerList.length; i++) {
            delete winnerPrizes[winnerList[i]];
        }
        delete winnerList;

        prizesDistributed = false;
        totalDistributed = 0;
        totalPrize = address(this).balance;

        emit DistributionReset();
    }

    // ========================= New Functions Added =========================

    // View contract balance
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

    // Check if a specific winner has received a prize
    function hasWinnerClaimed(address winner) external view returns (bool) {
        return winnerPrizes[winner] > 0;
    }

    // Remove a winner before distribution
    function removeWinner(address winner) external onlyOwner {
        require(!prizesDistributed, "Cannot remove after distribution");
        require(winnerPrizes[winner] > 0, "Winner not found");

        totalPrize -= winnerPrizes[winner];
        delete winnerPrizes[winner];

        for (uint i = 0; i < winnerList.length; i++) {
            if (winnerList[i] == winner) {
                winnerList[i] = winnerList[winnerList.length - 1];
                winnerList.pop();
                break;
            }
        }
    }

    // Update a specific winnerâ€™s prize before distribution
    function updateWinnerPrize(address winner, uint newPrize) external onlyOwner {
        require(!prizesDistributed, "Cannot update after distribution");
        require(winnerPrizes[winner] > 0, "Winner not found");

        uint currentPrize = winnerPrizes[winner];
        if (newPrize > currentPrize) {
            require(totalPrize >= totalDistributed + (newPrize - currentPrize), "Exceeds prize pool");
        }

        winnerPrizes[winner] = newPrize;
    }
}
