// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TournamentPrizeDistribution {
    address public owner;
    uint public totalPrize;
    uint public totalDistributed;
    mapping(address => uint) public winnerPrizes;
    address[] public winnerList;
    bool public prizesDistributed;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    event PrizeDistributed(address indexed winner, uint amount);
    event PrizePoolUpdated(uint newTotalPrize);
    event RemainingFundsWithdrawn(uint amount);
    event DistributionReset();
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event ContractDestroyed(address indexed destroyer, uint balanceTransferred);

    constructor() payable {
        owner = msg.sender;
        totalPrize = msg.value;
        prizesDistributed = false;
    }

    function distributePrizes(address[] calldata winners, uint[] calldata prizes) external onlyOwner {
        require(!prizesDistributed, "Prizes already distributed");
        require(winners.length == prizes.length, "Mismatch in winners and prizes");

        uint _totalDistributed = 0;

        for (uint i = 0; i < winners.length; i++) {
            winnerPrizes[winners[i]] = prizes[i];
            winnerList.push(winners[i]);
            _totalDistributed += prizes[i];
        }

        require(_totalDistributed <= totalPrize, "Exceeds total prize pool");

        for (uint i = 0; i < winners.length; i++) {
            payable(winners[i]).transfer(prizes[i]);
            emit PrizeDistributed(winners[i], prizes[i]);
        }

        totalDistributed = _totalDistributed;
        prizesDistributed = true;
    }

    function getPrizeAmount(address winner) external view returns (uint) {
        return winnerPrizes[winner];
    }

    function getAllWinners() external view returns (address[] memory) {
        return winnerList;
    }

    function updatePrizeAmount() external payable onlyOwner {
        require(!prizesDistributed, "Cannot add funds after distribution");
        totalPrize += msg.value;
        emit PrizePoolUpdated(totalPrize);
    }

    function withdrawUnclaimedFunds() external onlyOwner {
        require(prizesDistributed, "Distribution not completed");
        uint remaining = address(this).balance;
        payable(owner).transfer(remaining);
        emit RemainingFundsWithdrawn(remaining);
    }

    function resetDistribution() external onlyOwner {
        require(prizesDistributed, "Prizes not yet distributed");

        for (uint i = 0; i < winnerList.length; i++) {
            delete winnerPrizes[winnerList[i]];
        }
        delete winnerList;

        prizesDistributed = false;
        totalDistributed = 0;
        totalPrize = address(this).balance;

        emit DistributionReset();
    }

    // ========================= New Functions Already Added =========================

    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

    function hasWinnerClaimed(address winner) external view returns (bool) {
        return winnerPrizes[winner] > 0;
    }

    function removeWinner(address winner) external onlyOwner {
        require(!prizesDistributed, "Cannot remove after distribution");
        require(winnerPrizes[winner] > 0, "Winner not found");

        totalPrize -= winnerPrizes[winner];
        delete winnerPrizes[winner];

        for (uint i = 0; i < winnerList.length; i++) {
            if (winnerList[i] == winner) {
                winnerList[i] = winnerList[winnerList.length - 1];
                winnerList.pop();
                break;
            }
        }
    }

    function updateWinnerPrize(address winner, uint newPrize) external onlyOwner {
        require(!prizesDistributed, "Cannot update after distribution");
        require(winnerPrizes[winner] > 0, "Winner not found");

        uint currentPrize = winnerPrizes[winner];
        if (newPrize > currentPrize) {
            require(totalPrize >= totalDistributed + (newPrize - currentPrize), "Exceeds prize pool");
        }

        winnerPrizes[winner] = newPrize;
    }

    // ========================= New Functions Added Now =========================

    // Force distribute remaining balance proportionally to winners
    function distributeRemainingBalance() external onlyOwner {
        require(prizesDistributed, "Prizes not yet distributed");
        uint remaining = address(this).balance;
        require(remaining > 0, "No remaining balance");

        uint perWinner = remaining / winnerList.length;
        for (uint i = 0; i < winnerList.length; i++) {
            payable(winnerList[i]).transfer(perWinner);
            emit PrizeDistributed(winnerList[i], perWinner);
        }
    }

    // Force payout specific winner again
    function forcePayout(address winner) external onlyOwner {
        require(prizesDistributed, "Prizes not yet distributed");
        uint prize = winnerPrizes[winner];
        require(prize > 0, "Winner has no prize");
        payable(winner).transfer(prize);
        emit PrizeDistributed(winner, prize);
    }

    // Transfer ownership
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    // Destroy the contract and send balance to owner
    function destroyContract() external onlyOwner {
        emit ContractDestroyed(msg.sender, address(this).balance);
        selfdestruct(payable(owner));
    }
}
